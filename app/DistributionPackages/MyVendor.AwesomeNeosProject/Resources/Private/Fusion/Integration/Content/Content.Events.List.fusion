prototype(MyVendor.AwesomeNeosProject:Content.Events.List) < prototype(Neos.Neos:ContentComponent) {
    @context {
        tagsParameter = ${request.arguments.tags}
    }

    @cache {
        mode = 'dynamic'
        entryIdentifier {
            node = ${node}
            editPreviewMode = ${node.context.currentRenderingMode.name}
        }
        // if you add more parameters here you need to manually build an entry discriminator (`param1 + '___' + param2`)
        entryDiscriminator = ${tagsParameter}
        context {
            1 = 'node'
            2 = 'documentNode'
            3 = 'site'
            4 = 'tagsParameter'
        }
        entryTags {
            1 = ${Neos.Caching.nodeTag(node)}
            2 = ${Neos.Caching.nodeTypeTag('MyVendor.AwesomeNeosProject:Document.Blog.Tag', node)}
            3 = ${Neos.Caching.nodeTypeTag('MyVendor.AwesomeNeosProject:Document.Events.Event', node)}
        }
    }

    renderer = MyVendor.AwesomeNeosProject:Component.EventList {
        @context {
            futureItems = ${q(site).find('[instanceof MyVendor.AwesomeNeosProject:Document.Events.Event]').sort('date', 'ASC')}
            futureItems.@process.filterPastElements = ${Array.filter(value, item => q(item).property('date') >= Date.today() || q(item).property('dateUntil') >= Date.today())}

            // we get the tags from the inspector, extract their titles and join them with a comma (as this is what the filtering eel helper expects)
            tagsFromInspector = ${q(node).property('tags')}
            tagsFromInspector.@process.getTagNames = ${value ? Array.map(value, item => q(item).property('title')) : value}
            tagsFromInspector.@process.join = ${value ? Array.join(value, ',') : value}

            amountOfEvents = ${q(node).property('amountOfEvents')}
        }
        content = Neos.Fusion:Loop {
            items = ${futureItems}
            // when tags are selected in the inspector by the editor, we filter the events by those tags -> they always "win"
            // only if no tags are selected in the inspector, we allow frontend filtering for the end user via dropdown / tags request parameter
            items.@process.filterByTag = ${tagsFromInspector ? MyVendor.AwesomeNeosProject.FilterNodesByReference.filterNodes(value, 'tags', tagsFromInspector) : MyVendor.AwesomeNeosProject.FilterNodesByReference.filterNodes(value, 'tags', tagsParameter)}
            items.@process.limitAmountOfEvents = ${amountOfEvents > 0 ? Array.slice(value, 0, amountOfEvents) : value}
            itemRenderer = MyVendor.AwesomeNeosProject:Component.EventList.Event {
                title = ${q(item).property('title')}
                href = Neos.Neos:NodeUri {
                    node = ${item}
                }
                date = ${q(item).property('date')}
                // if an event spreads over multiple days, we normally want to render the first day as date.
                // if the first day is already in the past we render the current day.
                // all events in the past are filtered out above, so we shouldn't run into trouble with this.
                date.@process.dateForCurrentlyRunningEvents = ${q(item).property('date') < Date.today() ? Date.today() : value}
                timeFrom = ${q(item).property('timeFrom') ? Date.format(q(item).property('timeFrom'), 'H:i') : ''}
                timeTo = ${q(item).property('timeTo') ? Date.format(q(item).property('timeTo'), 'H:i') : ''}
                location = ${q(item).property('location')}
                tags = MyVendor.AwesomeNeosProject:Component.EventTagList {
                    tags = Neos.Fusion:Map {
                        items = ${q(item).property('tags')}
                        itemName = 'tag'
                        itemRenderer = Neos.Fusion:DataStructure {
                            title = ${q(tag).property('title')}
                        }
                    }
                }
            }
        }
        tags = Neos.Fusion:Case {
            tagsAreSelectedInInspector {
                condition = ${tagsFromInspector}
                // if tags are selected in the inspector, we don't want to show the tag filter
                renderer = ${null}
            }
            default {
                condition = ${true}
                renderer = Neos.Fusion:Map {
                    items = ${q(site).find('[instanceof MyVendor.AwesomeNeosProject:Document.Blog.Tag]')}
                    // for each tag we iterate over all future events and check if any of them has the current tag
                    items.@process.filterOutUnusedTags = ${Array.filter(value, item =>
                        !Array.isEmpty(
                            Array.filter(futureItems, event =>
                                q(event).property('tags') && Array.indexOf(q(event).property('tags'), item) > -1
                            )
                        )
                    )}
                    itemName = 'tag'
                    itemRenderer = Neos.Fusion:DataStructure {
                        title = ${q(tag).property('title')}
                        // we split the tagsParameter by comma and check if the current tag is in the list
                        isActive = ${Array.indexOf(String.split(String.toLowerCase(tagsParameter), ','), String.toLowerCase(q(tag).property('title'))) > -1}
                    }
                }
            }
        }
    }
}
